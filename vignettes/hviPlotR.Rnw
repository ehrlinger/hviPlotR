\documentclass[nojss]{jss}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{hviPlotR}
%\VignetteIndexEntry{Generating plot.sas style figures in R}
%\VignetteKeywords{publication graphics, powerpoint, ggplot2, plot.sas}
%\VignetteDepends{ggplot2}
%\VignettePackage{hviPlotR} 

%% almost as usual
\author{John Ehrlinger\\Cleveland Clinic} %\And \\Plus Affiliation}
\title{{\pkg{hviPlotR}}: Generating \code{plot.sas} style figures in \proglang{R}}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{John Ehrlinger} %% comma-separated
\Plaintitle{hviPlotR: Generating plot.sas style figures in R} %% without formatting
\Shorttitle{hviPlotR: Generating plot.sas style figures}

%% an abstract and keywords
\Abstract{ 
We introduce the \proglang{R} package \pkg{hviPlotR}, a set of tools for creating publication quality graphics in \proglang{R}. The \pkg{hviPlotR} package is designed to replace the \code{plot.sas} macro we currently use in \proglang{SAS}. The package includes both \proglang{R} recipes for generating our standard graphics using \pkg{ggplot2} commands and a set of themes designed to format those figures for both manuscript and \code{PowerPoint} targets. 

The goal of this package vignette is to introduce the \pkg{hviPlotR} methodology, as well as to document the best practices of creating our publication quality graphics for both manuscripts and power point presentations.

This document is included with the \pkg{hviPlotR} package as a package vignette, installed into \proglang{R} when the package is installed, and view able using the \code{vignette("hviPlotR")} command.
}
\Keywords{publication graphics, powerpoint, ggplot2, plot.sas}
\Plainkeywords{publication graphics, powerpoint, ggplot2, plot.sas}
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
John Ehrlinger\\
Quantitative Health Sciences\\
Lerner Research Institute\\
Cleveland Clinic\\
9500 Euclid Ave\\
Cleveland, Ohio 44195\\
%  Telephone: +41/0/44634-4643 \\
%  Fax: +41/0/44634-4386 \\
E-mail: \email{john.ehrlinger@gmail.com}\\
URL: \url{http://www.lerner.ccf.org/qhs/people/ehrlinj/}\\
URL: \url{https://github.com/ehrlinger/hviPlotR}
}

%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/1/31336-5053
%% Fax: +43/1/31336-734

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<setup,include=FALSE, cache=FALSE, echo=FALSE>>=
#' @import RColorBrewer devtools gridExtra reporttools scales xtable

library(knitr)
# set global chunk options for knitr. These can be changed in the header for each individual R code chunk
opts_chunk$set(fig.path='figure/beamer-', 
               fig.align='center',
               fig.pos="htpb",
               fig.show='hold', 
               fig.lp="F:",
               fig.height=5/4*3, fig.width=5,
               size='footnotesize',
               comment="", echo=TRUE, results=FALSE, message=FALSE, warning=FALSE,
               error=FALSE, dev='pdf')

# Setup the R environment
options(replace.assign=TRUE,object.size=Inf,expressions=100000,memory=Inf, width=100)

#################
# Load_packages #
#################
library(ggplot2) # Graphics engine for generating all types of plots
library(reshape2) # Used to modify the data for plotting
library(gridExtra) # for combined ggplots
library(RColorBrewer) # Color schemes
library(scales) # For modifying ggplot

library(dplyr) # Better data manipulations

#########################################################################
# Default computation settings
#########################################################################
@

\begin{document}

%% include your article here, just as usual
%% Note that you should use the \pkg{}, \proglang{} and \code{} commands.

<<introFigure, message=FALSE, warning=FALSE, echo=FALSE, fig.cap="Demonstration figure">>=
library(knitr)
library(ggplot2)
library(dplyr)
library(hviPlotR)

data(parametric, package="hviPlotR")
data(nonparametric, package="hviPlotR")


theme_set(theme_man())

## To reproduce the plot.sas function, line by line.
###-------------
## There are SAS options we will not use here.
#
#  %plot(goptions gsfmode=replace, device=pscolor, gaccess=gsasfile end;
ccf_plot <- ggplot()
# +
#   geom_vline(xintercept=0)+
#   geom_hline(yintercept=0)

#    id l="&STUDY/graphs/ce.states.ST_toJohn.sas percent", end;

###-------------
## Labels are a single command, scales control the axis
#
#    labelx l="Years After Randomization", end;
#      axisx order=(0 to 5 by 1), minor=none, end;
#    labely l="Percent in Each Category (ST)", end;
#      axisy order=(0 to 100 by 10), minor=none, end;
ccf_plot <- ccf_plot +
  labs(x="Years After Randomization",
       y="Percent in Each Category (ST)")+
  scale_x_continuous(breaks=seq(0,5,1))+
  scale_y_continuous(breaks=seq(0,100,10))


###-------------
## /******NON-PARAMETRIC: SYMBOLS AND CONFIDENCE BARS *******/
##
## Each tuple statement corresponds to one or more geom_ statements
#     tuple set=green, symbol=dot, symbsize=1/2, linepe=0, linecl=0,
#       ebarsize=3/4, ebar=1,
#       x=iv_state, y=sginit, cll=stlinit, clu=stuinit, color=black, end;

ccf_plot <- ccf_plot +
  geom_point(data=nonparametric, aes(x=iv_state, y=sginit))

#     tuple set=green, symbol=circle, symbsize=1/2, linepe=0, linecl=0,
#       ebarsize=3/4, ebar=1,
#       x=iv_state, y=sgdead1, cll=stldead1, clu=studead1, color=blue, end;
ccf_plot <- ccf_plot +
  geom_point(data=nonparametric, aes(x=iv_state, y=sgdead1),color="blue",shape=1) + 
  geom_errorbar(data=nonparametric, aes(x=iv_state, ymin=stldead1, ymax=studead1), 
                color="blue", width=.1)

#      tuple set=green, symbol=square, symbsize=1/2, linepe=0, linecl=0,
#       ebarsize=3/4, ebar=1,
#       x=iv_state, y=sgstrk1, cll=stlstrk1, clu=stustrk1, color=blue, end;
ccf_plot <- ccf_plot +
  geom_point(data=nonparametric, aes(x=iv_state, y=sgstrk1),color="blue",shape=0) + 
  geom_errorbar(data=nonparametric, aes(x=iv_state, ymin=stlstrk1, ymax=stustrk1), 
                color="blue", width=.1)

# /**********PARAMETRIC : SOLID LINES AND CONFIDENCE INTERVALS**********/      
# tuple set=all, x=years, y=noinit, cll=clinit, clu=cuinit,
# width=0.5,color=black, end;

ccf_plot <- ccf_plot+
  geom_line(data=parametric, aes(x=years, y=noinit))+
  geom_line(data=parametric, aes(x=years, y=clinit), linetype="dashed")+
  geom_line(data=parametric, aes(x=years, y=cuinit), linetype="dashed")
# 
# tuple set=all, x=years, y=nodeath, cll=cldeath, clu=cudeath,
# width=0.5,color=blue, end;
ccf_plot <- ccf_plot+
  geom_line(data=parametric, aes(x=years, y=nodeath), color="blue")+
  geom_line(data=parametric, aes(x=years, y=cldeath), linetype="dashed", color="blue")+
  geom_line(data=parametric, aes(x=years, y=cudeath), linetype="dashed", color="blue")
# 
# tuple set=all, x=years, y=nostrk, cll=clstrk, clu=custrk,
# linecl=2, width=0.5,color=blue, end;
ccf_plot <- ccf_plot+
  geom_line(data=parametric, aes(x=years, y=nostrk), color="blue")+
  geom_line(data=parametric, aes(x=years, y=clstrk), linetype="dashed", color="blue")+
  geom_line(data=parametric, aes(x=years, y=custrk), linetype="dashed", color="blue")

# Special commands to force origin to 0,0
ccf_plot+ coord_cartesian(xlim=c(0,5.2), ylim=c(0,101))
#   expand_limits(x = 0, y = 0) +
#   scale_x_continuous(expand = c(-0.1, 0.1)) + 
#   scale_y_continuous(expand = c(-1, 0.1))
@

% -----------------------------------------------------
\section{About this document}
% -----------------------------------------------------
This document is an introduction to the \proglang{R} package \pkg{hviPlotR}, a set of tools for creating publication quality graphics in \proglang{R}. The package and this document describe the process of creating graphics in \proglang{R} that conform to the standards of the clinical investigations statistics group within The Heart \& Vascular Institute at the Cleveland Clinic. These graphics are analogous to those generated with the \code{plot.sas} macro in \proglang{SAS}.

This document is the package vignette for the \pkg{hviPlotR} package, and as such is the primary documentation for the package. The latest version of the document can be obtained with the 
\begin{CodeChunk}
\begin{CodeInput}
R> vignette("hviPlotR", package = "hviPlotR")
\end{CodeInput}
\end{CodeChunk}

The goal is to update this document as the package is updated to include all relevant changes for publication. 

% -----------------------------------------------------
\section{Introduction}
% -----------------------------------------------------
For many years, the mainstay for generating graphics for manuscripts and presentations in the statistics group in HVI has been the \code{plot.sas} macro using \proglang{SAS}. However, recently, we have had issues migrating this macro to newer versions of \proglang{SAS} ($> 8.0$) and MicroSoft Office products ($> 2003$). 

In an effort to alleviate the versifying problems, and to standardize the generation of figures within \proglang{R}, we have developed the \pkg{hviPlotR} \proglang{R} package. The goal of the package, and this document, is simplify the creation of publication quality graphics in  \proglang{R}. We are specifically encoding the best practices of the HVI Clinical Investigations formatting, so that our statisticians will be able to simply create graphics for publication with a minimal amount of effort.

The \pkg{hviPlotR} package also implements best practices for \proglang{R} graphics by leveraging the \pkg{ggplot2} package~\citep{Wickham:2009}. The \pkg{ggplot2} package is an implementation of the Grammar of Graphics~\citep{Wilkinson:2005}, which is a formalization of graphical concepts, and the building of graphical objects from a sequence of independent components. These components can be combined in many different ways.

The \code{plot.sas} macro is also an implementation of a graphics grammar. The grammar is derived from the ZETA pen plotters, which used GML (Graphics Machine Language) to control between 4 and and 8 colored pens for generating color line and point figures. Because both systems use a graphics language it is straight forward to translate commands between the two methods. 

This document outlines how to generate figures using the \pkg{ggplot2} and \pkg{hviPlotR} packages. Our approach is to demonstrate the \proglang{R} commands to generate the same elements created with \code{plot.sas} commands. Section~\ref{S:plot.sas} gives an overview of the methodology of the \code{plot.sas} macro and Section~\ref{S:ggplot2tuple} details how to create line and point plots with \pkg{ggplot2}. A key part of \pkg{hviPlotR} package is custom themes for figures. Once you have created your figure, Section~\ref{S:themes} details how to get the formatting correct for manuscripts or presentations. Section~\ref{S:saving} describes functions for saving the figures to simplify the import into publication documents.

% -----------------------------------------------------
\section[The plot.sas macro]{The \code{plot.sas} macro}\label{S:plot.sas}
% -----------------------------------------------------
To demonstrate the process, we first look at some example code using the \code{plot.sas} macro. This code is intended to generate a figure for manuscript publication and was modified to generate Figure~\ref{F:introFigure}. Note the first line of the code block indicates the location of the file.

\begin{CodeChunk}\small
\begin{CodeInput}
%let STUDY=/studies/cardiac/valves/aortic/replacement/
partner_publication_office/partner1b/mortality_5y
*******************************************************************************;
* Bring in PostScript plot macro                                               ;
filename plt "!MACROS/plot.sas"; %inc plt;
filename gsasfile pipe 'lp';
*______________________________________________________________________________;
*                                                                              ;
*                       P O S T S C R I P T   P L O T S
*______________________________________________________________________________;
*                                                                              ;
* Multiple decrement, nonparametric and parametric                             ;
filename gsasfile "&STUDY/graphs/ce.states.ST_toJohn.both.ps";

*______________________________________________________________________________;
* Create the figure here   !                                                   ;
*______________________________________________________________________________;
%plot(goptions gsfmode=replace, device=pscolor, gaccess=gsasfile end;
id l="&STUDY/graphs/ce.states.ST_toJohn.sas percent", end;
labelx l="Years After Randomization", end;
axisx order=(0 to 5 by 1), minor=none, end;
labely l="Percent in Each Category (ST)", end;
axisy order=(0 to 100 by 10), minor=none, end;
\end{CodeInput}
\end{CodeChunk}

We interupt this command here for some explanation. The \code{plot.sas} macro call starts with the \code{\%plot} command. The first line sets global graphic values, including the file where the figure will be saved (see Section~\ref{S:saving}). Each \code{plot.sas} command is terminated with the \code{end;} statement. We'll look at each command type individually.

The \code{id l=} command sets the footnote text used for manuscript figures to identify where the figure is saved (see Section~\ref{S:saving}). The \code{labelx} and \code{labely} commands set the axis label text (Section~\ref{S:labels}) and the \code{axisx} and \code{axisy} set the scales for each axis locating text and tics (Section~\ref{S:scales}).

The \code{tuple} command builds up graphics objects within the figure plot window. The first set of tuple commands builds up a set of three elements containing both points (Section~\ref{S:points}) and errorbars (Section~\ref{S:errorbars}). Each \code{tuple} statement operates on a dataset indicated by the \code{set} command. 
\begin{CodeChunk}\small
\begin{CodeInput}
/******NON-PARAMETRIC: SYMBOLS AND CONFIDENCE BARS *******/
tuple set=green, symbol=dot, symbsize=1/2, linepe=0, linecl=0,
ebarsize=3/4, ebar=1,
x=iv_state, y=sginit, cll=stlinit, clu=stuinit, color=black, 
end;
tuple set=green, symbol=circle, symbsize=1/2, linepe=0, linecl=0,
ebarsize=3/4, ebar=1,
x=iv_state, y=sgdead1, cll=stldead1, clu=studead1, color=blue, 
end;
tuple set=green, symbol=square, symbsize=1/2, linepe=0, linecl=0,
ebarsize=3/4, ebar=1,
x=iv_state, y=sgstrk1, cll=stlstrk1, clu=stustrk1, color=blue, 
end;
\end{CodeInput}
\end{CodeChunk}
Symbols shapes and sizes are specified with the \code{symbol} and \code{symbsize} commands (Section~\ref{S:shapes}).

The second set of \code{tuple} statements build up a set of three elements containing lines and confidence intervals (Section~\ref{S:lines}).
\begin{CodeChunk}\small
\begin{CodeInput}

/**********PARAMETRIC : SOLID LINES AND CONFIDENCE INTERVALS**********/      
tuple set=all, x=years, y=noinit, cll=clinit, clu=cuinit,
width=0.5,color=black, 
end;

tuple set=all, x=years, y=nodeath, cll=cldeath, clu=cudeath,
width=0.5,color=blue, 
end;

tuple set=all, x=years, y=nostrk, cll=clstrk, clu=custrk,
linecl=2, width=0.5,color=blue, 
end;
);
run;
*******************************************************************************;
\end{CodeInput}
\end{CodeChunk}

The \code{plot.sas} macro code is closed by the ending \code{);} characters, and \proglang{SAS} is instructed to \code{run;} the code. Running combines building the figure by combining elements from \code{label}, \code{axis} and \code{tuple} statements and saving it into the file specified by the \code{gsasfile} variable. The resulting figure is shown in Figure~\ref{F:sasManuscript}.

\begin{figure}[!htpb]
\centering
\includegraphics[width=0.8\textwidth]{../inst/ceStatesST.pdf}
\caption{Manuscript figure (SAS version)}
\label{F:sasManuscript}
\end{figure}

Note that much of the figure formatting is mixed within the \code{tuple} statements using \code{width}, \code{color}, \code{linepe} and \code{linecl} commands. In the \code{plot.sas} macro, omitting these commands will generate a figure with the default values specified within the \code{device} theme (Section~\ref{S:themes}).


A similar set of \code{plot.sas} commands is used to create presentation graphics.
\begin{CodeChunk}\small\label{C:powerPoint}
\begin{CodeInput}
*______________________________________________________________________________;
*                                                                              ;
*       C G M   F I L E S   F O R   P O W E R P O I N T   S L I D E S
*______________________________________________________________________________;
*                                                                              ;
* Competing risks, parametric only                                             ;
filename gsasfile "&STUDY/graphs/ce.states.ST.cgm";
%plot(goptions gsfmode=replace, device=cgmmppa, ftext=hwcgm001, end;
axisx order=(0 to 5 by 1), minor=none, value=(height=2.4), end;
axisy order=(0 to 100 by 20), minor=none, value=(height=2.4), 
value=(height=2.4 j=r ' ' '20' '40' '60' '80' '100'), end;
tuple set=all, x=years, y=noinit, width=3, color=gray, end;
tuple set=all, x=years, y=nostrk, width=3, color=red, end;
tuple set=all, x=years, y=nodeath, width=3, color=blue, end;
);
run;  
\end{CodeInput}
\end{CodeChunk}
%\caption{SAS Code for powerpoint figure.\label{C:powerpoint}}
Differences include the target \code{device} and \code{ftext} as well as some handling of figure labels with \code{value} instead of \code{label} commands. We also have rules for what to and not to include in presentation graphics (Section~\ref{S:rules}).

\begin{figure}[!htpb]
\centering
\includegraphics[width=0.8\textwidth]{../inst/ceStatesST_ppt.pdf}
\caption{PowerPoint figure (SAS version)}
\label{F:sasPowerPoint}
\end{figure}

% -----------------------------------------------------
\section[Generating ggplot2 graphics]{Generating \pkg{ggplot2} graphics}\label{S:ggplot2tuple}
% -----------------------------------------------------

In order to create figures similar to the \code{plot.sas} macro, using \proglang{R}, we will make extensive use of the \pkg{ggplot2} package. This will require translating from the graphics language of \code{plot.sas} to the graphics language of \pkg{ggplot2}. 

For the remainder of this document, \proglang{R} code will be highlighted in grey boxes, as shown below. We will refer to these blocks as \emph{code chunks}. You can run each code chunk individuallym, using copy/paste into an interactive \proglang{R} session, or a stand alone \proglang{R} script.

This tutorial requires the \pkg{hviPlotR} package for data and themes we will be discussing. You can load it with the following commands:
<<installhviPlotR, eval=FALSE>>=
# Install the latest hviPlotR package.
#
# The devtools package is installed on all our 
# jjnb-gen servers as well as other R instances.
library(devtools) 

# To get the latest version.
install_github("ehrlinger/hviPlotR")
@


\subsection{Initialize the figure}\label{S:initial}
Refering back to the \proglang{SAS} code chunks in Section~\ref{S:plot.sas}, the first section of the code sets the current working directory, and does some house keeping, including loading the \code{plot.sas} macro. Similarly, to get started in \proglang{R}, we first load the required libraries: \pkg{ggplot2} for graphics, and \pkg{hviPlotR} for themes. The following code chunk also sets the initial default theme to a generic black and white format, and brings in a pair of example datasets. 
<<gettingStarted, message=FALSE, warning=FALSE>>=
# load required libraries
library(ggplot2)   # Plotting environment
library(hviPlotR)  # CCF HVI plotting functionality 

theme_set(theme_bw()) # A reasonable default plotting theme

# Load the example datasets 
data(parametric, package="hviPlotR")
data(nonparametric, package="hviPlotR")
@


One advantage of \pkg{ggplot2} is that figures can be built up in successive statements. This tutorial will make extensive use of this to demonstrate the process. Starting in this code chunk, we will save the intermediate objects in the \code{ccf_plot} variable. Here we simply create an empty \pkg{ggplot2} figure that we will be adding to as we work through the commands in the \code{plot.sas} macro. Note that we include the  \code{\%plot()} command in the comment above the equivalent \pkg{ggplot2} command.
<<openPlot>>=
## To reproduce the plot.sas function, line by line.
###-------------
## There are SAS options we will not use here.
#
#  %plot(goptions gsfmode=replace, device=pscolor, gaccess=gsasfile end;
ccf_plot <- ggplot()
@

\subsection{Labels}\label{S:labels}
The next section of the \proglang{SAS} code in Section~\ref{S:plot.sas} sets the x and y axis titles, as well as the location of the majoe axis tick marks. We will splot this up for our \proglang{R} code.  \pkg{ggplot2} uses a \code{labs} function to set the axis labels. 
<<labels>>=
###-------------
## Labels are a single command, scales control the axis
#
#    labelx l="Years After Randomization", end;
#    labely l="Percent in Each Category (ST)", end;
ccf_plot <- ccf_plot +
  labs(x="Years After Randomization",
       y="Percent in Each Category (ST)")
@

The \code{labs} function can also be used to set the plot \code{title} and legend titles. We will not cover that functionality here, details are available in~\cite{Wickham:2009} or through the Internet.

\subsection{Scales}\label{S:scales}
Axis ticks are controled with the \code{scale} functions. \pkg{ggplot2} has many different \code{scale} functions. These functions will work on one axis at a time, so for a typical continous axis, we refer to the \code{scale_x_continuous} or \code{scale_y_continuous} functions. Major axis are controlled using the \code{breaks} argument. This code uses a sequence of numbers to set the location of major tick marks (\code{seq(0,5,1)}). One mark for every year starting at 0, and ending at 5. Minor tick marks are automatically generated, but can also be specified using a \code{minor_breaks=} argument. You could also specifiy the breaks using a vector of values (\code{c(0,1,2,3,4,5)}), as well as relabel the ticks manually using a \code{labels=} argument.

Note that the \code{scale_} functions do not restrict the figure viewport at all. They are simply used to setup the axis tick marks. You can specify that the y-axis ticks are only from 0 to 50, and the figure would have a blank from 50 to the limits of the data. We discuss controlling the figure viewport in Section~\ref{S:globals}.

<<scales>>=
###-------------
## Labels are a single command, scales control the axis
#
#      axisx order=(0 to 5 by 1), minor=none, end;
#      axisy order=(0 to 100 by 10), minor=none, end;
ccf_plot <- ccf_plot +
  scale_x_continuous(breaks=seq(0,5,1))+
  scale_y_continuous(breaks=seq(0,100,10))
@

\subsection{Points}\label{S:points}
Up to this point, we have only created and \emph{decorated} the plot object stored in the \code{ccf_plot} variable. Showing the figure (\code{show}) or saving the figure would result in an error, since we have not added any data to the object, or described how we want it displayed. 

The fundamental statement of the \code{plot.sas} macro is the \code{tuple} statement. The first \code{tuple} statement we see in the example code sets the \emph{data} set (\code{set=green}), the symbol \emph{shape} (\code{symbol=dot}), \emph{size} (\code{symbsize=1/2}) and \emph{color} (\code{color=black}). It turns off lines so only points will be shown (\code{linepe=0, linecl=0,}). It also handles error bars (\code{ebarsize=3/4, ebar=1}), which will be discuss in Section~\ref{S:errorbars}. The last line tells the macro about the point placement (\code{x=iv_state, y=sginit, cll=stlinit, clu=stuinit}) for the points (x, y) and upper (\code{clu}) and lower (\code{cll}) error bar limits. 

The \code{geom_} set of functions in \pkg{ggplot2} is the functional equivalent to the \code{tuple} statement. The difference is the user specifies the graphical element desired using separate function calls. So points are plotting using the \code{geom_point} function, lines are generated with the \code{geom_line} (Section~\ref{S:lines}) and error bars are generated with the \code{geom_errorbar} function (Section~\ref{S:errorbars}).

Each of these functions takes a \code{data} argument, and an aesthetica function (\code{aes()}) is used to describe point within the graph using variables within the data set. The following code chunk demonstrates this use plotting the \code{iv_state} variable on the x-axis and the \code{sginit} variable along the y-axis. The variables are defined in the \code{nonparametric} data set we loaded in the setup code chunk in Section~\ref{S:ggplot2tuple}.
<<points, fig.cap="Point Plot">>=
###-------------
## /******NON-PARAMETRIC: SYMBOLS AND CONFIDENCE BARS *******/
##
## Each tuple statement corresponds to one or more geom_ statements
#     tuple set=green, symbol=dot, symbsize=1/2, linepe=0, linecl=0,
#       ebarsize=3/4, ebar=1,
#       x=iv_state, y=sginit, cll=stlinit, clu=stuinit, color=black, end;

ccf_plot <- ccf_plot +
  geom_point(data=nonparametric, aes(x=iv_state, y=sginit))

show(ccf_plot)
@
Once we have added data to the \code{ggplot} object, we can display the figure as shown in Figure~\ref{F:points}. Until know the figure has been manipulated by sequentially adding function calls to the \code{ccf_plot} object. To display the figure you can either use the \code{show()} function, or simply use the object name at the command line.

Note that we have used the default \emph{shape}, \emph{size} and \emph{color} for this figure. These can be manipulated by adding arguments to the \code{geom_} functions, outside of the \code{aes()} function, as we will demonstrate in the following sections.

\subsection{ErrorBars}\label{S:errorbars}

Instead of using a single function to set points, lines and error bars, \pkg{ggplot2} uses individual function calls to control these elements. The \code{geom_errorbar} function takes the same arguments as the other \code{geom_} functions. However, since an errorbar is defined with upper and lower limits, we need to supply an \code{ymax} and \code{ymin} argument to the graphic aesthetic function. This code chunk plots both points, and error bars for the next two data series, the \code{sgdead1} variable with errorbars running from \code{stldead1} to \code{studead1} and \code{sgstrk1} variable with errorbars running from \code{stlstrk1} to \code{stustrk1}. As we see in Figure~\ref{F:errorBars}, both series were added in \code{color="blue"}, with different point shapes (\code{shape=1} and \code{shape=0}). We manipulated the error bar size with the \code{width} argument

<<errorBars, warning=TRUE, fig.cap="Error Bar Plot">>=
#     tuple set=green, symbol=circle, symbsize=1/2, linepe=0, linecl=0,
#       ebarsize=3/4, ebar=1,
#       x=iv_state, y=sgdead1, cll=stldead1, clu=studead1, color=blue, end;
ccf_plot <- ccf_plot +
  geom_point(data=nonparametric, aes(x=iv_state, y=sgdead1),color="blue",shape=1) + 
  geom_errorbar(data=nonparametric, aes(x=iv_state, ymin=stldead1, ymax=studead1), 
                color="blue", width=.1)

#      tuple set=green, symbol=square, symbsize=1/2, linepe=0, linecl=0,
#       ebarsize=3/4, ebar=1,
#       x=iv_state, y=sgstrk1, cll=stlstrk1, clu=stustrk1, color=blue, end;
ccf_plot <- ccf_plot +
  geom_point(data=nonparametric, aes(x=iv_state, y=sgstrk1),color="blue",shape=0) + 
  geom_errorbar(data=nonparametric, aes(x=iv_state, ymin=stlstrk1, ymax=stustrk1), 
                color="blue", width=.1)

show(ccf_plot)
@

Note that the \code{x} variable is the same for all three data series and the associated error bars. Also, since we do not want an error bar at every data point, a large number points have the upper and lower error bar variables set to \code{NA}. This is the same behavior as the \code{plot.sas} macro. \pkg{ggplot2} does print warnings when we attempt to plot a series with missing values. We typically suppress those warnings, but left them here for illustration purposes only.

\subsection{Lines}\label{S:lines}
Similar to points and error bars, the \code{geom_line} function is used to plot lines. We use the \code{linetype} argument to specify the line styles. We do have to generate a seperate \code{geom_line} function call for each limit of the confidence limit, since it is constructed of two lines (the upper and lower confidence limit). Alternatively, we can use the \code{geom_ribbon} to generate the confidence band using a shaded region and only a single call. The aesthetic argument for \code{geom_ribbon} takes a \code{ymax} and \code{ymin} argument just as the \code{geom_errorbar} function.
<<lines, fig.cap="Line Plot with confidence bands">>=
# /**********PARAMETRIC : SOLID LINES AND CONFIDENCE INTERVALS**********/      
# tuple set=all, x=years, y=noinit, cll=clinit, clu=cuinit,
# width=0.5,color=black, end;

ccf_plot <- ccf_plot+
  geom_line(data=parametric, aes(x=years, y=noinit))+
  geom_line(data=parametric, aes(x=years, y=clinit), linetype="dashed")+
  geom_line(data=parametric, aes(x=years, y=cuinit), linetype="dashed")
# 
# tuple set=all, x=years, y=nodeath, cll=cldeath, clu=cudeath,
# width=0.5,color=blue, end;
ccf_plot <- ccf_plot+
  geom_line(data=parametric, aes(x=years, y=nodeath), color="blue")+
  geom_line(data=parametric, aes(x=years, y=cldeath), linetype="dashed", color="blue")+
  geom_line(data=parametric, aes(x=years, y=cudeath), linetype="dashed", color="blue")
# 
# tuple set=all, x=years, y=nostrk, cll=clstrk, clu=custrk,
# linecl=2, width=0.5,color=blue, end;
ccf_plot <- ccf_plot+
  geom_line(data=parametric, aes(x=years, y=nostrk), color="blue")+
  geom_line(data=parametric, aes(x=years, y=clstrk), linetype="dashed", color="blue")+
  geom_line(data=parametric, aes(x=years, y=custrk), linetype="dashed", color="blue")

show(ccf_plot)
@

This time, we used the \code{parametric} data set in the \code{data} argument, as we want to use a different set of points for generating these lines. 

\subsection{Linetypes}\label{S:linetypes}

<<linetypes, echo=FALSE, fig.cap="ggplot2 linetype table">>=
d=data.frame(lt=c("blank", "solid", "dashed", "dotted", "dotdash", "longdash", "twodash", "1F", "F1", "4C88C488", "12345678"))
ggplot() +
  scale_x_continuous(name="", limits=c(0,1), breaks=NULL) +
  scale_y_discrete(name="linetype") +
  scale_linetype_identity() +
  geom_segment(data=d, mapping=aes(x=0, xend=1, y=lt, yend=lt, linetype=lt))
@

\subsection{Shapes}\label{S:shapes}

<<shapes, echo=FALSE, fig.cap="ggplot2 shape table">>=
df <- data.frame(x=c(0:129))
ggplot(df, aes(x=x%%10, y=floor(x/10), shape=factor(x), size=10)) +
  geom_point() +
  scale_shape_manual(values=df$x) + theme(legend.position='none') +
  scale_x_continuous(breaks=0:10) + scale_y_continuous(breaks=0:12) +
  labs(x="ones", y="tens")
@

\subsection{Colors}\label{S:colors}

\subsection{Global Commands}\label{S:globals}

<<global,, fig.cap="Adjusting the viewport">>=
# Special commands to force origin to 0,0
ccf_plot <- ccf_plot+ coord_cartesian(xlim=c(0,5.2), ylim=c(0,101))
#   expand_limits(x = 0, y = 0) +
#   scale_x_continuous(expand = c(-0.1, 0.1)) + 
#   scale_y_continuous(expand = c(-1, 0.1))

show(ccf_plot)
@


% -----------------------------------------------------
\section{PowerPoint Figures}\label{S:powerPointFigures}
% -----------------------------------------------------

As a second example, we recreate a figure that was created for PowerPoint with the \code{plot.sas} macro. In most cases, we do not include points when generating presentation figures, so this figure was generated with only \code{geom_line} function calls. We also show how the figure can be created in a single set of function calls.

<<powerpoint, fig.cap="PowerPoint Figures">>=
# %plot(goptions gsfmode=replace, device=cgmmppa, ftext=hwcgm001, end;
# axisx order=(0 to 5 by 1), minor=none, value=(height=2.4), end;
# axisy order=(0 to 100 by 20), minor=none, value=(height=2.4), 
# value=(height=2.4 j=r ' ' '20' '40' '60' '80' '100'), end;
# tuple set=all, x=years, y=noinit, width=3, color=gray, end;
# tuple set=all, x=years, y=nostrk, width=3, color=red, end;
# tuple set=all, x=years, y=nodeath, width=3, color=blue, end;
# );
ccf_pptPlot <- ggplot()+
  scale_x_continuous(breaks=seq(0,5,1))+
  scale_y_continuous(breaks=seq(0,100,20))+
  geom_line(data=parametric, aes(x=years, y=noinit), color="grey", size=2)+
  geom_line(data=parametric, aes(x=years, y=nostrk), color="red", size=2)+
  geom_line(data=parametric, aes(x=years, y=nodeath), color="blue", size=2)

show(ccf_pptPlot)
@


% -----------------------------------------------------
\section[Themes for publications]{\pkg{ggplot2} themes for publication}\label{S:themes}
% -----------------------------------------------------

\subsection{Theme for Manuscripts}
<<manuscriptTheme, fig.cap="Theme for Manuscripts">>=
theme_set(theme_man())
ccf_plot

theme_set(theme_bw())
@


\subsection{Theme for Presentations}
<<powerpointTheme, fig.cap="Theme for Presentations">>=
ccf_pptPlot+
  labs(x="",y="")+
  theme_ppt() +
  theme(plot.background = element_rect(fill='blue', colour='blue', size=2))
@
% -----------------------------------------------------
\section{Saving Publication graphics}\label{S:saving}
% -----------------------------------------------------

\subsection{Manuscript graphics}
<<storage>>=
#    id l="&STUDY/graphs/ce.states.ST_toJohn.sas percent", end;
@

\subsection{PowerPoint graphics}
<<PPTstorage, eval=FALSE>>=
library(ReporteRs)
#    id l="&STUDY/graphs/ce.states.ST_toJohn.sas percent", end;

# Create a powerPoint document using ../inst/RDPresentation.pptx 
# as a template document.
doc = pptx(template=paste("../inst/RDPresentation.pptx", sep=""))

# Here we define powerpoint document filename to write
# the presentation. This will be overwritten
pptx.file = paste("RDExample.pptx", sep="")

##--------
# For each graph, addSlide. The graphs require the 
# “Title and Content” template.
doc = addSlide( doc, "Title and Content" )

# Place a title
doc=addTitle( doc, "Treatment Difference" )

# Now add the graph into the powerPoint doc 
doc = addPlot( doc=doc, fun=print, 
               x=ccf_pptPlot+theme_ppt() ,
               editable = TRUE,
               offx=.75, offy=1.1, width=8, height=6)
##--------
## IF you want to add more, just repeat between the “—————“ comments
##--------

# write the output powerpoint doc. 
# This will not overwrite an open document, since open PPT files are locked.
writeDoc( doc, pptx.file )
@


% -----------------------------------------------------
\section{Generating other figure types}\label{S:alternateFigures}
% -----------------------------------------------------

\subsection{Bar Charts}

\subsection{Histograms}

\subsection{Additional Figure Types}


% -----------------------------------------------------
\section{Graphics rules to live by}\label{S:rules}
% -----------------------------------------------------

% =======================================
\section{Conclusions} \label{S:concl}
% =======================================
In this article, we present some functions in the \pkg{hviPlotR} package for \proglang{R} 

% =======================================
% \section{Literatur} \label{sec: references}
% =======================================
%\nocite{*}

\bibliography{hviPlotR}



\end{document}